// Code generated by MockGen. DO NOT EDIT.
// Source: usecase/interfaces.go
//
// Generated by this command:
//
//	mockgen -source=usecase/interfaces.go -destination=usecase/interfaces_mock.go -package=usecase
//

// Package usecase is a generated GoMock package.
package usecase

import (
	reflect "reflect"

	uuid "github.com/google/uuid"
	entity "github.com/lucas-moura1/mercadobitcoin-challenge/entity"
	decimal "github.com/shopspring/decimal"
	gomock "go.uber.org/mock/gomock"
	gorm "gorm.io/gorm"
)

// MockOrderUseCase is a mock of OrderUseCase interface.
type MockOrderUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockOrderUseCaseMockRecorder
	isgomock struct{}
}

// MockOrderUseCaseMockRecorder is the mock recorder for MockOrderUseCase.
type MockOrderUseCaseMockRecorder struct {
	mock *MockOrderUseCase
}

// NewMockOrderUseCase creates a new mock instance.
func NewMockOrderUseCase(ctrl *gomock.Controller) *MockOrderUseCase {
	mock := &MockOrderUseCase{ctrl: ctrl}
	mock.recorder = &MockOrderUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockOrderUseCase) EXPECT() *MockOrderUseCaseMockRecorder {
	return m.recorder
}

// CancelOrder mocks base method.
func (m *MockOrderUseCase) CancelOrder(id uuid.UUID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CancelOrder", id)
	ret0, _ := ret[0].(error)
	return ret0
}

// CancelOrder indicates an expected call of CancelOrder.
func (mr *MockOrderUseCaseMockRecorder) CancelOrder(id any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CancelOrder", reflect.TypeOf((*MockOrderUseCase)(nil).CancelOrder), id)
}

// CreateOrder mocks base method.
func (m *MockOrderUseCase) CreateOrder(order *entity.Order) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateOrder", order)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateOrder indicates an expected call of CreateOrder.
func (mr *MockOrderUseCaseMockRecorder) CreateOrder(order any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateOrder", reflect.TypeOf((*MockOrderUseCase)(nil).CreateOrder), order)
}

// GetOrderBook mocks base method.
func (m *MockOrderUseCase) GetOrderBook(instrumentPair string) (*OrderBook, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetOrderBook", instrumentPair)
	ret0, _ := ret[0].(*OrderBook)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetOrderBook indicates an expected call of GetOrderBook.
func (mr *MockOrderUseCaseMockRecorder) GetOrderBook(instrumentPair any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetOrderBook", reflect.TypeOf((*MockOrderUseCase)(nil).GetOrderBook), instrumentPair)
}

// MockAccountUseCase is a mock of AccountUseCase interface.
type MockAccountUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockAccountUseCaseMockRecorder
	isgomock struct{}
}

// MockAccountUseCaseMockRecorder is the mock recorder for MockAccountUseCase.
type MockAccountUseCaseMockRecorder struct {
	mock *MockAccountUseCase
}

// NewMockAccountUseCase creates a new mock instance.
func NewMockAccountUseCase(ctrl *gomock.Controller) *MockAccountUseCase {
	mock := &MockAccountUseCase{ctrl: ctrl}
	mock.recorder = &MockAccountUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAccountUseCase) EXPECT() *MockAccountUseCaseMockRecorder {
	return m.recorder
}

// GetAccountBalance mocks base method.
func (m *MockAccountUseCase) GetAccountBalance(accountID uuid.UUID) ([]*entity.Wallet, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAccountBalance", accountID)
	ret0, _ := ret[0].([]*entity.Wallet)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAccountBalance indicates an expected call of GetAccountBalance.
func (mr *MockAccountUseCaseMockRecorder) GetAccountBalance(accountID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAccountBalance", reflect.TypeOf((*MockAccountUseCase)(nil).GetAccountBalance), accountID)
}

// MockTradeExecutor is a mock of TradeExecutor interface.
type MockTradeExecutor struct {
	ctrl     *gomock.Controller
	recorder *MockTradeExecutorMockRecorder
	isgomock struct{}
}

// MockTradeExecutorMockRecorder is the mock recorder for MockTradeExecutor.
type MockTradeExecutorMockRecorder struct {
	mock *MockTradeExecutor
}

// NewMockTradeExecutor creates a new mock instance.
func NewMockTradeExecutor(ctrl *gomock.Controller) *MockTradeExecutor {
	mock := &MockTradeExecutor{ctrl: ctrl}
	mock.recorder = &MockTradeExecutorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTradeExecutor) EXPECT() *MockTradeExecutorMockRecorder {
	return m.recorder
}

// Execute mocks base method.
func (m *MockTradeExecutor) Execute(tx *gorm.DB, taker, maker *entity.Order, qty decimal.Decimal) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", tx, taker, maker, qty)
	ret0, _ := ret[0].(error)
	return ret0
}

// Execute indicates an expected call of Execute.
func (mr *MockTradeExecutorMockRecorder) Execute(tx, taker, maker, qty any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockTradeExecutor)(nil).Execute), tx, taker, maker, qty)
}
